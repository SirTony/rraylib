use std::fs::File;
use std::io::Write;
use std::path::{Path, PathBuf};
use bindgen::CargoCallbacks;
use chrono::Local;

#[derive(Debug, Clone)]
struct Package<'a> {
    name: &'static str,
    version: &'static str,
    url: &'static str,
    headers: Vec<&'static str>,
    dir: &'a Path,
}

impl<'a> Package<'a> {
    fn download(&self) -> anyhow::Result<()> {
        let url = format!("{}/{}.zip", self.url, self.version);
        let path = PathBuf::from(self.dir.join(self.zip_file_name()));
        let mut data = reqwest::blocking::get(&url)?;
        let mut file = File::create(&path)?;

        data.copy_to(&mut file)?;
        file.flush()?;

        Ok(())
    }

    fn extract( &self ) -> anyhow::Result<()> {
        let path = PathBuf::from(self.dir.join(self.zip_file_name()));
        let mut file = File::open(&path)?;

        zip_extract::extract(&mut file, self.dir, false)?;

        Ok(())
    }

    fn zip_file_name(&self) -> String {
        format!("{}.zip", self.name)
    }

    fn out_dir(&self) -> PathBuf {
        self.dir.join(format!("{}-{}", self.name, self.version))
    }
}

fn main() -> anyhow::Result<()> {
    const WRAPPER_H: &str = "wrapper.h";
    const WRAPPER_C: &str = "wrapper.c";

    let dir = std::env::current_dir()?.join("vendor");
    std::fs::create_dir_all(&dir)?;

    let raylib = Package {
        name: "raylib",
        version: "5.5",
        url: "https://github.com/raysan5/raylib/archive/refs/tags",
        headers: vec!["raylib.h", "raymath.h", "rlgl.h"],
        dir: &dir,
    };

    let raygui = Package {
        name: "raygui",
        version: "4.0",
        url: "https://github.com/raysan5/raygui/archive/refs/tags",
        headers: vec!["raygui.h"],
        dir: &dir,
    };

    let physac = Package {
        name: "Physac",
        version: "1.1",
        url: "https://github.com/victorfisac/Physac/archive/refs/tags",
        headers: vec!["physac.h"],
        dir: &dir,
    };

    let wrapper = dir.join(WRAPPER_H);
    let mut file = File::create(&wrapper)?;
    let bindings = bindgen::Builder::default()
        .header(wrapper.display().to_string())
        .prepend_enum_name(false)
        .parse_callbacks(Box::new(CargoCallbacks::new()));
    let packages = vec![raylib.clone(), raygui, physac];

    writeln!(file, "// Generated by {} at {}", env!("CARGO_PKG_NAME"), Local::now())?;
    writeln!(file, "" )?;

    for package in &packages {
        package.download()?;
        package.extract()?;
        for header in &package.headers {
            let header = package.out_dir().join("src").join(header);
            writeln!(file, "#include <{}>", header.display())?;
        }
    }

    file.flush()?;
    std::mem::forget(file);

    let bindings = bindings
        .blocklist_item("PI")
        .blocklist_item("EPSILON")
        .blocklist_item("_.*?_H")
        .blocklist_item("DEG2RAD")
        .blocklist_item("RAD2DEG")
        .blocklist_item("^FP_.*?")
        .blocklist_item("^M_.*?")
        .blocklist_item("^(false|true)_")
        .blocklist_item("^__bool_.*?")
        .generate()?;
    let sys = dir.join("..").join("src").join("sys.rs");
    let mut file = File::create(sys)?;

    bindings.write(Box::new(&file))?;
    file.flush()?;
    std::mem::forget(file);

    let wrapper = dir.join(WRAPPER_C);
    cc::Build::new()
        .include(&dir)
        .file(&wrapper)
        .compile("rraylib");

    cmake::Config::new(raylib.out_dir()).build();

    let search_dirs = vec![ "lib64", "lib", "bin" ];
    for search_dir in search_dirs {
        println!("cargo:rustc-link-search=native={}", raylib.out_dir().join(search_dir).display());
    }

    println!("cargo:rustc-link-lib=static=rraylib");
    println!("cargo:rustc-link-lib=static=raylib");
    println!("cargo:rerun-if-changed=build.rs");

    Ok(())
}